$date
	Fri Sep 13 22:07:02 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module reg_writer_test $end
$var wire 5 ! regnum [4:0] $end
$var wire 1 " done $end
$var reg 1 # clock $end
$var reg 32 $ data [31:0] $end
$var reg 1 % direction $end
$var reg 1 & go $end
$var reg 1 ' reset $end
$var integer 32 ( i [31:0] $end
$scope module rf $end
$var wire 1 # clock $end
$var wire 32 ) internal_rdData [31:0] $end
$var wire 32 * rdData [31:0] $end
$var wire 1 + rdWriteEnable $end
$var wire 1 ' reset $end
$var wire 32 , rsData [31:0] $end
$var wire 5 - rsNum [4:0] $end
$var wire 32 . rtData [31:0] $end
$var wire 5 / rtNum [4:0] $end
$var wire 5 0 rdNum [4:0] $end
$var integer 32 1 i [31:0] $end
$upscope $end
$scope module writer $end
$var wire 1 # clock $end
$var wire 1 % direction $end
$var wire 1 " done $end
$var wire 1 & go $end
$var wire 1 ' reset $end
$var wire 1 2 sDone_next $end
$var wire 1 3 sDown1_next $end
$var wire 1 4 sDown2_next $end
$var wire 1 5 sDown3_next $end
$var wire 1 6 sDown4_next $end
$var wire 1 7 sGarbage_next $end
$var wire 1 8 sStart_next $end
$var wire 1 9 sUp1_next $end
$var wire 1 : sUp2_next $end
$var wire 1 ; sUp3_next $end
$var wire 1 < sUp4_next $end
$var wire 1 = sUp4 $end
$var wire 1 > sUp3 $end
$var wire 1 ? sUp2 $end
$var wire 1 @ sUp1 $end
$var wire 1 A sStart $end
$var wire 1 B sGarbage $end
$var wire 1 C sDown4 $end
$var wire 1 D sDown3 $end
$var wire 1 E sDown2 $end
$var wire 1 F sDown1 $end
$var wire 1 G sDone $end
$var wire 5 H regnum [4:0] $end
$scope module fsDone $end
$var wire 1 # clk $end
$var wire 1 2 d $end
$var wire 1 I enable $end
$var wire 1 J reset $end
$var reg 1 G q $end
$upscope $end
$scope module fsDown1 $end
$var wire 1 # clk $end
$var wire 1 3 d $end
$var wire 1 K enable $end
$var wire 1 L reset $end
$var reg 1 F q $end
$upscope $end
$scope module fsDown2 $end
$var wire 1 # clk $end
$var wire 1 4 d $end
$var wire 1 M enable $end
$var wire 1 N reset $end
$var reg 1 E q $end
$upscope $end
$scope module fsDown3 $end
$var wire 1 # clk $end
$var wire 1 5 d $end
$var wire 1 O enable $end
$var wire 1 P reset $end
$var reg 1 D q $end
$upscope $end
$scope module fsDown4 $end
$var wire 1 # clk $end
$var wire 1 6 d $end
$var wire 1 Q enable $end
$var wire 1 R reset $end
$var reg 1 C q $end
$upscope $end
$scope module fsGarbage $end
$var wire 1 # clk $end
$var wire 1 7 d $end
$var wire 1 S enable $end
$var wire 1 T reset $end
$var reg 1 B q $end
$upscope $end
$scope module fsStart $end
$var wire 1 # clk $end
$var wire 1 8 d $end
$var wire 1 U enable $end
$var wire 1 V reset $end
$var reg 1 A q $end
$upscope $end
$scope module fsUp1 $end
$var wire 1 # clk $end
$var wire 1 9 d $end
$var wire 1 W enable $end
$var wire 1 X reset $end
$var reg 1 @ q $end
$upscope $end
$scope module fsUp2 $end
$var wire 1 # clk $end
$var wire 1 : d $end
$var wire 1 Y enable $end
$var wire 1 Z reset $end
$var reg 1 ? q $end
$upscope $end
$scope module fsUp3 $end
$var wire 1 # clk $end
$var wire 1 ; d $end
$var wire 1 [ enable $end
$var wire 1 \ reset $end
$var reg 1 > q $end
$upscope $end
$scope module fsUp4 $end
$var wire 1 # clk $end
$var wire 1 < d $end
$var wire 1 ] enable $end
$var wire 1 ^ reset $end
$var reg 1 = q $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0^
1]
0\
1[
0Z
1Y
0X
1W
0V
1U
0T
1S
0R
1Q
0P
1O
0N
1M
0L
1K
0J
1I
b0xxxx H
xG
xF
xE
xD
xC
xB
xA
x@
x?
x>
x=
0<
0;
0:
09
08
17
06
05
04
03
02
b100000 1
b0xxxx 0
bz /
bx .
bz -
bx ,
x+
bx *
bx )
bx (
1'
0&
0%
bx $
0#
x"
b0xxxx !
$end
#1
b0 !
b0 0
b0 H
1+
1B
0A
0@
0?
0>
0=
0F
0E
0D
0C
0"
0G
1#
#2
0#
0'
#3
1#
#4
18
07
0#
b110100000000 $
b110100000000 *
1&
#5
b1000 !
b1000 0
b1000 H
0B
1A
1#
b110100000000 )
#6
08
13
0#
b110100000001 $
b110100000001 *
0&
#7
03
14
b111 !
b111 0
b111 H
1F
0A
1#
b110100000001 )
#8
0#
b110100000010 $
b110100000010 *
#9
b110 !
b110 0
b110 H
04
15
0F
1E
1#
b110100000010 )
#10
0#
b110100000011 $
b110100000011 *
#11
b101 !
b101 0
b101 H
16
05
1D
0E
1#
b110100000011 )
#12
0#
b110100000100 $
b110100000100 *
#13
b100 !
b100 0
b100 H
12
06
0D
1C
1#
b110100000100 )
#14
0#
b110100000101 $
b110100000101 *
#15
b0 !
b0 0
b0 H
0+
1"
1G
0C
1#
b110100000101 )
#16
0#
#17
1#
#18
0#
#19
1#
#20
0#
b1110 (
#21
1#
#22
02
b100000 1
17
0#
1'
#23
1+
0"
0G
1B
1#
#24
0#
0'
#25
1#
#26
18
07
0#
1%
b110111111111 $
b110111111111 *
1&
#27
b1000 !
b1000 0
b1000 H
1A
0B
1#
b110111111111 )
#28
08
19
0#
b110111111110 $
b110111111110 *
0&
#29
09
b1001 !
b1001 0
b1001 H
1:
0A
1@
1#
b110111111110 )
#30
0#
b110111111101 $
b110111111101 *
#31
b1010 !
b1010 0
b1010 H
1;
0:
1?
0@
1#
b110111111101 )
#32
0#
b110111111100 $
b110111111100 *
#33
b1011 !
b1011 0
b1011 H
0;
1<
0?
1>
1#
b110111111100 )
#34
0#
b110111111011 $
b110111111011 *
#35
b1100 !
b1100 0
b1100 H
12
0<
1=
0>
1#
b110111111011 )
#36
0#
b110111111010 $
b110111111010 *
#37
b0 !
b0 0
b0 H
0+
0=
1"
1G
1#
b110111111010 )
#38
0#
#39
1#
#40
0#
#41
1#
#42
0#
b1110 (
